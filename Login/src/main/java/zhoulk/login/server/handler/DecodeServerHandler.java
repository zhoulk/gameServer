package zhoulk.login.server.handler;

import io.netty.buffer.*;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import org.apache.log4j.Logger;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;
import zhoulk.login.server.model.client.CMDLoginOtherPlatform;
import zhoulk.tool.convert.ConvertUtils;
import zhoulk.tool.model.CMDCmd;
import zhoulk.tool.model.CMDHead;

/**
 * Created by zlk on 2018/4/17.
 */

@Service("LoginDecodeServerHandler")
@Scope("prototype")
@ChannelHandler.Sharable
public class DecodeServerHandler extends ChannelInboundHandlerAdapter {

    private static Logger logger = Logger.getLogger(DecodeServerHandler.class);

    public byte[] DECODE_MAP_NEW = new byte[256];
    String decodeStr = "" +
            "0x03,0xbd,0x5a,0x2c,0x63,0xa8,0x91,0x8c,0x56,0x4c,0x67,0xc5,0x2f,0x38,0x16,0xd1," +
            "0xe7,0xd3,0xa2,0x0c,0x93,0x31,0x69,0xc1,0xaa,0xb9,0xdc,0x52,0xc7,0x78,0xd5,0x3d," +
            "0xb2,0xcb,0x39,0xfa,0x21,0xd4,0x7f,0x23,0xed,0x75,0xbf,0x57,0xbc,0xc0,0x92,0xdb," +
            "0xf1,0x66,0x02,0x74,0x82,0x47,0x95,0x90,0x01,0x14,0x55,0x1e,0x45,0x6b,0x9e,0x17," +
            "0xc4,0xa5,0x12,0x60,0xac,0x04,0x62,0xf2,0x06,0x70,0xf6,0x6e,0x0e,0xa1,0x3e,0xf8," +
            "0xc3,0x1c,0xb8,0x54,0xea,0xad,0xb7,0x5f,0x40,0x48,0xb5,0x9f,0x24,0xec,0xb0,0xe4," +
            "0x77,0x71,0xe8,0x85,0xc9,0x15,0xf3,0x42,0x5c,0xb1,0x5d,0x8a,0xa4,0x28,0x18,0x7c," +
            "0xba,0xc2,0x26,0x0b,0x2e,0x3c,0xa7,0xa9,0x9b,0x9c,0xef,0x97,0x46,0x99,0x72,0xc6," +
            "0xd2,0x61,0x4f,0x05,0xc8,0x9a,0x6a,0x88,0x2d,0xb3,0x7a,0xfe,0xfc,0x7e,0xae,0xcd," +
            "0x43,0x32,0xb6,0xab,0xd8,0xca,0xd9,0xb4,0x68,0x19,0xe9,0x00,0x3a,0xeb,0x59,0x79," +
            "0x4b,0xe5,0x84,0x96,0x6f,0xe2,0xe0,0x65,0x87,0x1f,0x29,0x6d,0x34,0x98,0x83,0x1a," +
            "0x49,0xe1,0x4a,0x76,0x58,0x0a,0x33,0x8b,0x07,0xcc,0x51,0x30,0x2a,0xfb,0x0d,0x8e," +
            "0xf7,0x64,0x25,0xa6,0x9d,0xff,0x8f,0x7b,0xf5,0x08,0xa0,0xe6,0x94,0x89,0xf0,0xe3," +
            "0x50,0x4e,0x1b,0x5b,0x27,0xcf,0x20,0x80,0x09,0xf9,0x2b,0x4d,0x41,0xda,0x3f,0x53," +
            "0xd6,0x11,0x86,0xde,0xdf,0xaf,0x22,0x3b,0x35,0x5e,0xa3,0x37,0x13,0xbe,0x81,0x36," +
            "0xce,0x44,0x1d,0xf4,0x0f,0xbb,0x7d,0xdd,0x8d,0x73,0xd7,0xee,0xfd,0xd0,0x10,0x6c";

    public DecodeServerHandler() {
        super();
        logger.info("ParseCmdServerHandler intizlize -----");

        String str[] = decodeStr.split(",");
        for(int i=0; i<str.length; i++){
            str[i] = str[i].substring(2);
        }
        DECODE_MAP_NEW = ConvertUtils.hexStringToBytes(String.join("", str));
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        logger.info("ParseCmdServerHandler added -----");
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

        logger.info("收到 " + ByteBufUtil.hexDump((ByteBuf) msg));

        //ctx.writeAndFlush(msg);

        ByteBuf in = (ByteBuf) msg;
        // 解析头
        CMDHead head = new CMDHead();
        head.decode(in);
        // 解析体
        convertBytes(in, head);

        ctx.fireChannelRead(in);

    }

    // 字节转换
    void convertBytes(ByteBuf in, CMDHead head){
        if(in.readableBytes() >= head.getwPacketSize() - head.len()) {
            byte[] src = ByteBufUtil.getBytes(in, 0, head.getwPacketSize());
            for (int i = 0; i < src.length; i++) {
                src[i] = DECODE_MAP_NEW[src[i] & 0xff];
            }

            in.setBytes(0, src);
        }else{
            logger.error("协议头长度和体长度不符!!!!!" + " 可读长度"+in.readableBytes() + " 目标长度" + head.getwPacketSize());
        }
    }
}
